# 🚀 LeetCode Solutions - Easy 🟢

This folder contains my solutions for **Easy** LeetCode problems. Each problem includes a description, examples, constraints, and a link to the solution file.

## ⚡ How to Use This Folder

1. Find the problem in the **Table of Contents**.
2. Click the solution link to open the corresponding `.java` file.
3. Run the solution in a Java environment:
   ```sh
   javac 0001.java && java TwoSum
4. Modify and test with your own input.

|   | # | Problem | Solution |  |
|---|---|---------|----------|--|
| 1  | 1  | [Two Sum](#-two-sum)  | [➔](Solutions/0001.java) | ✔ |
| 2  | 9  | [Palindrome Number](#-palindrome-number)  | [➔](Solutions/0009.java) | ✔ |
| 3  | 13 | [Roman to Integer](#-roman-to-integer)  | [➔](Solutions/0013.java) | ✔ |
| 4  | 14 | [Longest Common Prefix](#-longest-common-prefix)  | [➔](Solutions/0014.java) | ✔ |
| 5  | 20 | [Valid Parentheses](#-valid-parentheses)  | [➔](Solutions/0020.java) | ✔ |
| 6  | 26 | [Remove Duplicates from Sorted Array](#-remove-duplicates-from-sorted-array)  | [➔](Solutions/0026.java) | ✔ |
| 7  | 27 | [Remove Element](#-remove-element)  | [➔](Solutions/0027.java) | ✔ |
| 8  | 28 | [Find the Index of the First Occurrence in a String](#-find-the-index-of-the-first-occurrence-in-a-string)  | [➔](Solutions/0028.java) | ✔ |
| 9  | 35 | [Search Insert Position](#-search-insert-position)  | [➔](Solutions/0035.java) | ✔ |
| 10 | 58 | [Length of Last Word](#-length-of-last-word)  | [➔](Solutions/0058.java) | ✔ |
| 11 | 66 | [Plus One](#-plus-one)  | [➔](Solutions/0066.java) | ✔ |
| 12 | 67 | [Add Binary](#-add-binary)  | [➔](Solutions/0067.java) | ✔ |
| 13 | 69 | [Sqrt(x)](#-sqrtx)  | [➔](Solutions/0069.java) | ✔ |
| 14 | 70 | [Climbing Stairs](#-climbing-stairs)  | [➔](Solutions/0070.java) | ✔ |
| 15 | 121 | [Best Time to Buy and Sell Stock](#-best-time-to-buy-and-sell-stock)  | [➔](Solutions/0121.java) | ✔ |
| 16 | 242 | [Valid Anagram](#-valid-anagram)  | [➔](Solutions/0242.java) | ✔ |
| 17 | 283 | [Move Zeroes](#-move-zeroes)  | [➔](Solutions/0283.java) | ✔ |
| 18 | 345 | [Reverse Vowels of a String](#-reverse-vowels-of-a-string)  | [➔](Solutions/0345.java) | ✔ |
| 19 | 383 | [Ransom Note](#-ransom-note)  | [➔](Solutions/0383.java) | ✔ |
| 20 | 389 | [Find the Difference](#-find-the-difference)  | [➔](Solutions/0389.java) | ✔ |
| 21 | 392 | [Is Subsequence](#-is-subsequence)  | [➔](Solutions/0392.java) | ✔ |
| 22 | 412 | [Fizz Buzz](#-fizz-buzz)  | [➔](Solutions/0412.java) | ✔ |
| 23 | 459 | [Repeated Substring Pattern](#-repeated-substring-pattern)  | [➔](Solutions/0459.java) | ✔ |
| 24 | 509 | [Fibonacci Number](#-fibonacci-number)  | [➔](Solutions/0509.java) | ✔ |
| 25 | 605 | [Can Place Flowers](#-can-place-flowers)  | [➔](Solutions/0605.java) | ✔ |
| 26 | 643 | [Maximum Average Subarray I](#-maximum-average-subarray-i)  | [➔](Solutions/0643.java) | ✔ |
| 27 | 657 | [Robot Return to Origin](#-robot-return-to-origin)  | [➔](Solutions/0657.java) | ✔ |
| 28 | 682 | [Baseball Game](#-baseball-game)  | [➔](Solutions/0682.java) | ✔ |
| 29 | 709 | [To Lower Case](#-to-lower-case)  | [➔](Solutions/0709.java) | ✔ |
| 30 | 724 | [Find Pivot Index](#-find-pivot-index)  | [➔](Solutions/0724.java) |  |
| 31 | 860 | [Lemonade Change](#-lemonade-change)  | [➔](Solutions/0860.java) | ✔ |
| 32 | 896 | [Monotonic Array](#-monotonic-array)  | [➔](Solutions/0896.java) | ✔ |
| 33 | 976 | [Largest Perimeter Triangle](#-largest-perimeter-triangle)  | [➔](Solutions/0976.java) |  |
| 34 | 1137 | [N-th Tribonacci Number](#-n-th-tribonacci-number)  | [➔](Solutions/1137.java) |  |
| 35 | 1207 | [Unique Number of Occurrences](#-unique-number-of-occurrences)  | [➔](Solutions/1207.java) |  |
| 36 | 1232 | [Check If It Is a Straight Line](#-check-if-it-is-a-straight-line)  | [➔](Solutions/1232.java) |  |
| 37 | 1275 | [Find Winner on a Tic Tac Toe Game](#-find-winner-on-a-tic-tac-toe-game)  | [➔](Solutions/1275.java) |  |
| 38 | 1342 | [Number of Steps to Reduce a Number to Zero](#-number-of-steps-to-reduce-a-number-to-zero)  | [➔](Solutions/1342.java) |  |
| 39 | 1431 | [Kids With the Greatest Number of Candies](#-kids-with-the-greatest-number-of-candies)  | [➔](Solutions/1431.java) |  |
| 40 | 1475 | [Final Prices With a Special Discount in a Shop](#-final-prices-with-a-special-discount-in-a-shop)  | [➔](Solutions/1475.java) |  |
| 41 | 1480 | [Running Sum of 1d Array](#-running-sum-of-1d-array)  | [➔](Solutions/1480.java) |  |
| 42 | 1491 | [Average Salary Excluding the Minimum and Maximum Salary](#-average-salary-excluding-the-minimum-and-maximum-salary)  | [➔](Solutions/1491.java) |  |
| 43 | 1502 | [Can Make Arithmetic Progression From Sequence](#-can-make-arithmetic-progression-from-sequence)  | [➔](Solutions/1502.java) |  |
| 44 | 1523 | [Count Odd Numbers in an Interval Range](#-count-odd-numbers-in-an-interval-range)  | [➔](Solutions/1523.java) |  |
| 45 | 1572 | [Matrix Diagonal Sum](#-matrix-diagonal-sum)  | [➔](Solutions/1572.java) |  |
| 46 | 1672 | [Richest Customer Wealth](#-richest-customer-wealth)  | [➔](Solutions/1672.java) |  |
| 47 | 1732 | [Find the Highest Altitude](#-find-the-highest-altitude)  | [➔](Solutions/1732.java) |  |
| 48 | 1768 | [Merge Strings Alternately](#-merge-strings-alternately)  | [➔](Solutions/1768.java) |  |
| 49 | 1822 | [Sign of the Product of an Array](#-sign-of-the-product-of-an-array)  | [➔](Solutions/1822.java) |  |
| 50 | 2215 | [Find the Difference of Two Arrays](#-find-the-difference-of-two-arrays)  | [➔](Solutions/2215.java) |  |
| 51 | 2379 | [Minimum Recolors to Get K Consecutive Black Blocks](#-minimum-recolors-to-get-k-consecutive-black-blocks)  | [➔](Solutions/2379.java) |  |
| 52 | 2529 | [Maximum Count of Positive Integer and Negative Integer](#-maximum-count-of-positive-integer-and-negative-integer)  | [➔](Solutions/2529.java) |  |
| 53 | 2558 | [Take Gifts From the Richest Pile](#-take-gifts-from-the-richest-pile)  | [➔](Solutions/2558.java) |  |
| 54 | 2965 | [Find Missing and Repeated Values](#-find-missing-and-repeated-values)  | [➔](Solutions/2965.java) |  |
| 55 | 3467 | [Transform Array by Parity](#-transform-array-by-parity)  | [➔](Solutions/3467.java) |  |

## 📝 Problem Descriptions

### ✅ Two Sum
**Difficulty:** 🟢 Easy

**Problem Statement:**  
Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`.  

You may assume that each input would have exactly one solution, and you may not use the same element twice.  
You can return the answer in any order.  

**Example:**  

Input: `nums = [2,7,11,15]`, target = `9`  
Output: `[0,1]`  
Explanation: Because `nums[0] + nums[1] == 9`, we return `[0, 1]`.  

Input: `nums = [3,2,4]`, target = `6`  
Output: `[1,2]`  

Input: `nums = [3,3]`, target = `6`  
Output: `[0,1]`  

**Constraints:**  
- `2 <= nums.length <= 10^4`  
- `-10^9 <= nums[i] <= 10^9`  
- `-10^9 <= target <= 10^9`  
- Only one valid answer exists.  

**Hints:**  
1. A really brute force way would be to search for all possible pairs of numbers, but that would be too slow. Again, it's best to try out brute force solutions just for completeness. It is from these brute force solutions that you can come up with optimizations.  
2. So, if we fix one of the numbers, say `x`, we have to scan the entire array to find the next number `y` which is `target - x`. Can we change our array somehow so that this search becomes faster?  
3. The second train of thought is, without changing the array, can we use additional space somehow? Like maybe a hash map to speed up the search?  

[📂 Solution](Solutions/0001.java)

[⬆️ Go to top](#top)

---

### ✅ Palindrome Number 
**Difficulty:** 🟢 Easy

**Problem Statement:**  
Given an integer `x`, return `true` if `x` is a palindrome, and `false` otherwise.  

**Example:**  

Input: `x = 121`  
Output: `true`  
Explanation: `121` reads as `121` from left to right and from right to left.  

Input: `x = -121`  
Output: `false`  
Explanation: From left to right, it reads `-121`. From right to left, it becomes `121-`. Therefore, it is not a palindrome.  

Input: `x = 10`  
Output: `false`  
Explanation: Reads `01` from right to left. Therefore, it is not a palindrome.  

**Constraints:**  
- `-2^31 <= x <= 2^31 - 1`  

**Hints:**  
1. Beware of overflow when you reverse the integer.  

[📂 Solution](Solutions/0009.java)

[⬆️ Go to top](#top)

---

### ✅ Roman to Integer 
**Difficulty:** 🟢 Easy

**Problem Statement:**  
Roman numerals are represented by seven different symbols:  

| Symbol | Value |
|--------|-------|
| I      | 1     |
| V      | 5     |
| X      | 10    |
| L      | 50    |
| C      | 100   |
| D      | 500   |
| M      | 1000  |

For example, `2` is written as `II` in Roman numerals, just two ones added together. `12` is written as `XII`, which is simply `X + II`. The number `27` is written as `XXVII`, which is `XX + V + II`.  

Roman numerals are usually written from largest to smallest from left to right. However, there are six instances where subtraction is used:  

- `I` can be placed before `V` (5) and `X` (10) to make `4` and `9`.  
- `X` can be placed before `L` (50) and `C` (100) to make `40` and `90`.  
- `C` can be placed before `D` (500) and `M` (1000) to make `400` and `900`.  

Given a Roman numeral `s`, convert it to an integer.  

**Example:**  

Input: `s = "III"`  
Output: `3`  
Explanation: `III = 3`.  

Input: `s = "LVIII"`  
Output: `58`  
Explanation: `L = 50`, `V = 5`, `III = 3`.  

Input: `s = "MCMXCIV"`  
Output: `1994`  
Explanation: `M = 1000`, `CM = 900`, `XC = 90` and `IV = 4`.  

**Constraints:**  
- `1 <= s.length <= 15`  
- `s` contains only the characters `('I', 'V', 'X', 'L', 'C', 'D', 'M')`.  
- It is guaranteed that `s` is a valid Roman numeral in the range `[1, 3999]`.  

**Hints:**  
1. The problem is simpler to solve by working through the string from back to front and using a map.  

[📂 Solution](Solutions/0013.java)

[⬆️ Go to top](#top)  

---
### ✅ Longest Common Prefix  
**Difficulty:** 🟢 Easy  
**Problem Statement:**  
Write a function to find the **longest common prefix** string amongst an array of strings.  

If there is **no common prefix**, return an **empty string** `""`.  

**Example:**  

Input: `strs = ["flower","flow","flight"]`  
Output: `"fl"`  

Input: `strs = ["dog","racecar","car"]`  
Output: `""`  
Explanation: There is no common prefix among the input strings.  

**Constraints:**  
- `1 <= strs.length <= 200`  
- `0 <= strs[i].length <= 200`  
- `strs[i]` consists of only lowercase English letters.  

**Hints:**  
1. The **horizontal scanning** method compares prefixes of each word one by one.  
2. The **vertical scanning** method compares each character position across all words.  
3. A **binary search** method can be used to find the longest prefix efficiently.  

[📂 Solution](Solutions/0014.java)  

[⬆️ Go to top](#top)  

---

### ✅ Valid Parentheses  
**Difficulty:** 🟢 Easy  
**Problem Statement:**  
Given a string `s` containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['`, and `']'`, determine if the input string is **valid**.  

A string is **valid** if:  
- Open brackets must be closed by the same type of brackets.  
- Open brackets must be closed in the correct order.  
- Every closing bracket has a corresponding open bracket of the same type.  

**Example:**  

Input: `s = "()"`  
Output: `true`  

Input: `s = "()[]{}"`  
Output: `true`  

Input: `s = "(]"`  
Output: `false`  

Input: `s = "([])"`  
Output: `true`  

**Constraints:**  
- `1 <= s.length <= 10^4`  
- `s` consists only of `()[]{}`  

**Hints:**  
1. Use a **stack** to keep track of open brackets.  
2. When encountering an **opening bracket**, push it onto the stack.  
3. When encountering a **closing bracket**, check if it matches the **top of the stack**. If it does, pop the stack; otherwise, return `false`.  

[📂 Solution](Solutions/0020.java)  

[⬆️ Go to top](#top)  

---

### ✅ Remove Duplicates from Sorted Array
**Difficulty:** 🟢 Easy

**Problem Statement:**  
Given an integer array `nums` sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in `nums`.  

Consider the number of unique elements of `nums` to be `k`. To get accepted, you need to do the following:  

- Modify the array `nums` such that the first `k` elements contain the unique elements in the order they appeared in `nums` initially.  
- The remaining elements of `nums` are not important.  
- Return `k`.  

**Example:**  

Input: `nums = [1,1,2]`  
Output: `2, nums = [1,2,_]`  
Explanation: Your function should return `k = 2`, with the first two elements of `nums` being `1` and `2` respectively.  

Input: `nums = [0,0,1,1,1,2,2,3,3,4]`  
Output: `5, nums = [0,1,2,3,4,_,_,_,_,_]`  
Explanation: Your function should return `k = 5`, with the first five elements of `nums` being `0, 1, 2, 3, and 4` respectively.  

**Constraints:**  
- `1 <= nums.length <= 3 * 10^4`  
- `-100 <= nums[i] <= 100`  
- `nums` is sorted in non-decreasing order.  

**Hints:**  
1. The key point to focus on is that the input array is sorted. Consider the positioning of duplicate elements in the sorted array.
</br><img src="https://github.com/user-attachments/assets/f7503246-a798-4c55-829d-2677429734a6" alt="drawing" width="400" align='center'/></br>
2. We need to modify the array in-place, so a two-pointer approach is useful: one pointer to track the current element in the original array and another for unique elements.  
3. Once an element is encountered, bypass its duplicates and move to the next unique element.  

[📂 Solution](Solutions/0026.java) 

[⬆️ Go to top](#top)

---

### ✅ Remove Element  
**Difficulty:** 🟢 Easy

**Problem Statement:**  
Given an integer array `nums` and an integer `val`, remove all occurrences of `val` in `nums` in-place. The order of the elements may be changed. Then return the number of elements in `nums` which are not equal to `val`.  

Consider the number of elements in `nums` that are not equal to `val` as `k`. To get accepted, you need to do the following:  

- Modify the array `nums` such that the first `k` elements contain the elements which are not equal to `val`.  
- The remaining elements of `nums` are not important.  
- Return `k`.  

**Example:**  

Input: `nums = [3,2,2,3]`, `val = 3`  
Output: `2, nums = [2,2,_,_]`  
Explanation: Your function should return `k = 2`, with the first two elements of `nums` being `2`.  
It does not matter what you leave beyond the returned `k` (hence they are underscores).  

Input: `nums = [0,1,2,2,3,0,4,2]`, `val = 2`  
Output: `5, nums = [0,1,4,0,3,_,_,_]`  
Explanation: Your function should return `k = 5`, with the first five elements of `nums` being `0, 1, 4, 0, and 3`.  
The five elements can be returned in any order.  
It does not matter what you leave beyond the returned `k` (hence they are underscores).  

**Constraints:**  
- `0 <= nums.length <= 100`  
- `0 <= nums[i] <= 50`  
- `0 <= val <= 100`  

**Hints:**  
1. The problem asks us to modify the array in-place, but elements beyond the new length can be anything.  
2. We can move all occurrences of `val` to the end of the array using two pointers.
</br><img src="https://github.com/user-attachments/assets/990e3ed1-bf53-4b1d-b4ca-3053aaf626d1" alt="drawing" width="400" align='center'/></br>
3. Another approach is to copy the non-`val` elements in-place in a single pass.  

[📂 Solution](Solutions/0027.java)  

[⬆️ Go to top](#top)  

---

### ✅ Find the Index of the First Occurrence in a String  
**Difficulty:** 🟢 Easy

**Problem Statement:**  
Given two strings `needle` and `haystack`, return the index of the first occurrence of `needle` in `haystack`, or `-1` if `needle` is not part of `haystack`.  

**Example:**  

Input: `haystack = "sadbutsad"`, `needle = "sad"`  
Output: `0`  
Explanation: `"sad"` occurs at index `0` and `6`.  
The first occurrence is at index `0`, so we return `0`.  

Input: `haystack = "leetcode"`, `needle = "leeto"`  
Output: `-1`  
Explanation: `"leeto"` did not occur in `"leetcode"`, so we return `-1`.  

**Constraints:**  
- `1 <= haystack.length, needle.length <= 10^4`  
- `haystack` and `needle` consist of only lowercase English characters.  

[📂 Solution](Solutions/0028.java)  

[⬆️ Go to top](#top)  

---

### ✅ Search Insert Position  
**Difficulty:** 🟢 Easy

**Problem Statement:**  
Given a sorted array of **distinct** integers and a `target` value, return the index if the `target` is found.  
If not, return the index where it would be if it were inserted in order.  

You must write an algorithm with **O(log n)** runtime complexity.  

**Example:**  

Input: `nums = [1,3,5,6]`, `target = 5`  
Output: `2`  

Input: `nums = [1,3,5,6]`, `target = 2`  
Output: `1`  

Input: `nums = [1,3,5,6]`, `target = 7`  
Output: `4`  

**Constraints:**  
- `1 <= nums.length <= 10^4`  
- `-10^4 <= nums[i] <= 10^4`  
- `nums` contains **distinct** values sorted in **ascending order**.  
- `-10^4 <= target <= 10^4`  

[📂 Solution](Solutions/0035.java)  

[⬆️ Go to top](#top)  

---

### ✅ Length of Last Word  
**Difficulty:** 🟢 Easy 

**Problem Statement:**  
Given a string `s` consisting of words and spaces, return the **length** of the **last word** in the string.  

A **word** is a maximal substring consisting of **non-space** characters only.  

**Example:**  

Input: `s = "Hello World"`  
Output: `5`  
Explanation: The last word is `"World"` with length `5`.  

Input: `s = "   fly me   to   the moon  "`  
Output: `4`  
Explanation: The last word is `"moon"` with length `4`.  

Input: `s = "luffy is still joyboy"`  
Output: `6`  
Explanation: The last word is `"joyboy"` with length `6`.  

**Constraints:**  
- `1 <= s.length <= 10^4`  
- `s` consists of only **English letters** and **spaces (' ')**.  
- There will be at least **one word** in `s`.  

[📂 Solution](Solutions/0058.java)  

[⬆️ Go to top](#top)  

---

### ✅ Plus One  
**Difficulty:** 🟢 Easy  

**Problem Statement:**  
You are given a **large integer** represented as an integer array `digits`, where each `digits[i]` is the `i`-th digit of the integer. The digits are ordered from **most significant** to **least significant** in left-to-right order. The large integer does **not** contain any leading `0`s.  

Increment the large integer by **one** and return the resulting array of digits.  

**Example:**  

Input: `digits = [1,2,3]`  
Output: `[1,2,4]`  
Explanation: The array represents the integer `123`.  
Incrementing by one gives `123 + 1 = 124`.  
Thus, the result should be `[1,2,4]`.  

Input: `digits = [4,3,2,1]`  
Output: `[4,3,2,2]`  
Explanation: The array represents the integer `4321`.  
Incrementing by one gives `4321 + 1 = 4322`.  
Thus, the result should be `[4,3,2,2]`.  

Input: `digits = [9]`  
Output: `[1,0]`  
Explanation: The array represents the integer `9`.  
Incrementing by one gives `9 + 1 = 10`.  
Thus, the result should be `[1,0]`.  

**Constraints:**  
- `1 <= digits.length <= 100`  
- `0 <= digits[i] <= 9`  
- `digits` does **not** contain any leading `0`s.  

[📂 Solution](Solutions/0066.java)  

[⬆️ Go to top](#top)  

---

### ✅ Add Binary  
**Difficulty:** 🟢 Easy 

**Problem Statement:**  
Given two **binary strings** `a` and `b`, return **their sum** as a binary string.  

**Example:**  

Input: `a = "11"`, `b = "1"`  
Output: `"100"`  

Input: `a = "1010"`, `b = "1011"`  
Output: `"10101"`  

**Constraints:**  
- `1 <= a.length, b.length <= 10^4`  
- `a` and `b` consist only of `'0'` or `'1'` characters.  
- Each string does not contain **leading zeros** except for the zero itself.  

[📂 Solution](Solutions/0067.java)  
 
[⬆️ Go to top](#top)  

---

### ✅ Sqrt(x)  
**Difficulty:** 🟢 Easy

**Problem Statement:**  
Given a **non-negative integer** `x`, return the **square root** of `x` **rounded down** to the nearest integer.  
The returned integer should be **non-negative** as well.  

🚨 **You must not use any built-in exponent function** or operator like `pow(x, 0.5)` or `x ** 0.5`.  

**Example:**  

Input: `x = 4`  
Output: `2`  
Explanation: The square root of 4 is `2`, so we return `2`.  

Input: `x = 8`  
Output: `2`  
Explanation: The square root of 8 is `2.82842...`, and since we round it **down** to the nearest integer, `2` is returned.  

**Constraints:**  
- `0 <= x <= 2^31 - 1`  

**Hints:**  
1. Try **exploring all integers**.  
2. Use the **sorted property** of integers to reduce the search space (consider binary search).  

[📂 Solution](Solutions/0069.java)  

[⬆️ Go to top](#top)  

---

### ✅ Climbing Stairs  
**Difficulty:** 🟢 Easy  
**Problem Statement:**  
You are climbing a staircase. It takes `n` steps to reach the top.  

Each time you can either climb **1** or **2** steps. In how many distinct ways can you reach the top?  

**Example:**  

Input: `n = 2`  
Output: `2`  
Explanation: There are two ways to climb to the top:  
1. `1 step + 1 step`  
2. `2 steps`  

Input: `n = 3`  
Output: `3`  
Explanation: There are three ways to climb to the top:  
1. `1 step + 1 step + 1 step`  
2. `1 step + 2 steps`  
3. `2 steps + 1 step`  

**Constraints:**  
- `1 <= n <= 45`  

**Hints:**  
1. To reach the `n`th step, you must have come from either `(n-1)`th step (1 step) or `(n-2)`th step (2 steps).  
2. This forms a **Fibonacci sequence** where `f(n) = f(n-1) + f(n-2)`, with base cases `f(1) = 1`, `f(2) = 2`.  

[📂 Solution](Solutions/0070.java)  

[⬆️ Go to top](#top)  

---

### ✅ Best Time to Buy and Sell Stock  
**Difficulty:** 🟢 Easy  

**Problem Statement:**  
You are given an array `prices` where `prices[i]` is the price of a given stock on the `i`th day.  

You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.  

Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return `0`.  

**Example 1:**  
**Input:** prices = [7,1,5,3,6,4]  
**Output:** 5  
**Explanation:**  
- Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6 - 1 = 5.  
- Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.  

**Example 2:**  
**Input:** prices = [7,6,4,3,1]  
**Output:** 0  
**Explanation:**  
- In this case, no transactions are done and the max profit = 0.  

**Constraints:**  
- 1 <= prices.length <= 10⁵  
- 0 <= prices[i] <= 10⁴  

[📂 Solution](Solutions/0121.java)  

[⬆️ Go to top](#top)  

---

### ✅ Valid Anagram  
**Difficulty:** 🟢 Easy  
**Problem Statement:**  
Given two strings `s` and `t`, return `true` if `t` is an **anagram** of `s`, and `false` otherwise.  

**Example:**  

Input: `s = "anagram"`, `t = "nagaram"`  
Output: `true`  

Input: `s = "rat"`, `t = "car"`  
Output: `false`  

**Constraints:**  
- `1 <= s.length, t.length <= 5 * 10^4`  
- `s` and `t` consist of **lowercase English letters**.  

**Follow-up:**  
- What if the inputs contain **Unicode characters**? How would you adapt your solution to handle this case?  

[📂 Solution](Solutions/0242.java)  

[⬆️ Go to top](#top)  

---

### ✅ Move Zeroes  
**Difficulty:** 🟢 Easy  
**Problem Statement:**  
Given an integer array `nums`, move all `0`s to the **end** of it while maintaining the **relative order** of the non-zero elements.  

**Note:**  
- You must do this **in-place** without making a copy of the array.  

**Example:**  

Input: `nums = [0,1,0,3,12]`  
Output: `[1,3,12,0,0]`  

Input: `nums = [0]`  
Output: `[0]`  

**Constraints:**  
- `1 <= nums.length <= 10^4`  
- `-2^31 <= nums[i] <= 2^31 - 1`  

**Hints:**  
1. **In-place** means we **cannot** allocate extra space. But as a first step, try solving it using an **additional array**, then work on optimizing it.  
2. A **two-pointer** approach can be useful. One pointer iterates through the array, while the other keeps track of the position to place the next non-zero element.  

[📂 Solution](Solutions/0283.java)  

[⬆️ Go to top](#top)  

---

### ✅ Reverse Vowels of a String  
**Difficulty:** 🟢 Easy  

**Problem Statement:**  
Given a string `s`, reverse only all the vowels in the string and return it.  

The vowels are `'a', 'e', 'i', 'o', 'u'` (both lowercase and uppercase).  

**Example 1:**  
**Input:** s = "IceCreAm"  
**Output:** "AceCreIm"  
**Explanation:**  
- The vowels in `s` are `['I', 'e', 'e', 'A']`.  
- On reversing the vowels, `s` becomes `"AceCreIm"`.  

**Example 2:**  
**Input:** s = "leetcode"  
**Output:** "leotcede"  

**Constraints:**  
- 1 <= s.length <= 3 × 10⁵  
- `s` consists of printable ASCII characters.  

[📂 Solution](Solutions/0345.java)  

[⬆️ Go to top](#top)  

---

### ✅ Ransom Note  
**Difficulty:** 🟢 Easy  
**Problem Statement:**  
Given two strings `ransomNote` and `magazine`, return `true` if `ransomNote` **can be constructed** by using the letters from `magazine` and `false` otherwise.  

Each letter in `magazine` can **only be used once** in `ransomNote`.  

**Example:**  

Input: `ransomNote = "a", magazine = "b"`  
Output: `false`  

Input: `ransomNote = "aa", magazine = "ab"`  
Output: `false`  

Input: `ransomNote = "aa", magazine = "aab"`  
Output: `true`  

**Constraints:**  
- `1 <= ransomNote.length, magazine.length <= 10^5`  
- `ransomNote` and `magazine` consist of **lowercase English letters**.  

**Hints:**  
1. Count the frequency of each letter in both strings.  
2. Use a hash map (or an array of size 26) to track available letters.  
3. If any letter in `ransomNote` exceeds its count in `magazine`, return `false`.  

[📂 Solution](Solutions/0383.java)  

[⬆️ Go to top](#top)  

---

### ✅ Find the Difference  
**Difficulty:** 🟢 Easy  
**Problem Statement:**  
You are given two strings `s` and `t`.  

String `t` is generated by randomly shuffling string `s` and then adding **one more letter** at a random position.  

Return the letter that was added to `t`.  

**Example:**  

Input: `s = "abcd"`, `t = "abcde"`  
Output: `"e"`  
Explanation: `'e'` is the letter that was added.  

Input: `s = ""`, `t = "y"`  
Output: `"y"`  

**Constraints:**  
- `0 <= s.length <= 1000`  
- `t.length == s.length + 1`  
- `s` and `t` consist of **lowercase English letters**.  

**Hints:**  
1. Use frequency counting (hash map or array of size 26).  
2. XOR all characters from both `s` and `t`, the result will be the extra letter.  

[📂 Solution](Solutions/0389.java)  

[⬆️ Go to top](#top)  

---

### ✅ Is Subsequence  
**Difficulty:** 🟢 Easy  

**Problem Statement:**  
Given two strings `s` and `t`, return `true` if `s` is a **subsequence** of `t`, or `false` otherwise.  

A **subsequence** of a string is a new string that is formed from the original string by deleting some (can be none) of the characters **without disturbing the relative positions** of the remaining characters.  
(i.e., `"ace"` is a subsequence of `"abcde"` while `"aec"` is not).  

**Example 1:**  
**Input:** s = "abc", t = "ahbgdc"  
**Output:** true  

**Example 2:**  
**Input:** s = "axc", t = "ahbgdc"  
**Output:** false  

**Constraints:**  
- 0 <= s.length <= 100  
- 0 <= t.length <= 10⁴  
- `s` and `t` consist only of lowercase English letters.  

**Follow-up:**  
- Suppose there are lots of incoming `s`, say `s1, s2, ..., sk` where `k >= 10⁹`, and you want to check one by one to see if `t` has its subsequence. How would you optimize your code?  

[📂 Solution](Solutions/0392.java)  

[⬆️ Go to top](#top)  

---

### ✅ Fizz Buzz  
**Difficulty:** 🟢 Easy  
**Problem Statement:**  
Given an integer `n`, return a string array `answer` (1-indexed) where:  

- `answer[i] == "FizzBuzz"` if `i` is divisible by **3 and 5**.  
- `answer[i] == "Fizz"` if `i` is divisible by **3**.  
- `answer[i] == "Buzz"` if `i` is divisible by **5**.  
- `answer[i] == i` (as a string) if none of the above conditions are true.  

**Example:**  

Input: `n = 3`  
Output: `["1","2","Fizz"]`  

Input: `n = 5`  
Output: `["1","2","Fizz","4","Buzz"]`  

Input: `n = 15`  
Output: `["1","2","Fizz","4","Buzz","Fizz","7","8","Fizz","Buzz","11","Fizz","13","14","FizzBuzz"]`  

**Constraints:**  
- `1 <= n <= 10^4`  

**Hints:**  
1. Loop from `1` to `n` and check divisibility conditions.  
2. Use `if-else` statements to construct the result dynamically.  

[📂 Solution](Solutions/0412.java)  

[⬆️ Go to top](#top)  

---

### ✅ Repeated Substring Pattern  
**Difficulty:** 🟢 Easy  
**Problem Statement:**  
Given a string `s`, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.  

**Example:**  

Input: `s = "abab"`  
Output: `true`  
Explanation: It is the substring `"ab"` twice.  

Input: `s = "aba"`  
Output: `false`  

Input: `s = "abcabcabcabc"`  
Output: `true`  
Explanation: It is the substring `"abc"` four times or the substring `"abcabc"` twice.  

**Constraints:**  
- `1 <= s.length <= 10^4`  
- `s` consists of lowercase English letters.  

**Hints:**  
1. Consider concatenating `s` with itself and removing the first and last character.  
2. Check if `s` exists as a substring within this new string.  

[📂 Solution](Solutions/0459.java)  

[⬆️ Go to top](#top)  

---

### ✅ Fibonacci Number  
**Difficulty:** 🟢 Easy  

**Problem Statement:**  
The Fibonacci numbers, commonly denoted `F(n)`, form a sequence called the Fibonacci sequence, where each number is the sum of the two preceding ones, starting from `0` and `1`. That is:  

- `F(0) = 0`, `F(1) = 1`  
- `F(n) = F(n - 1) + F(n - 2)`, for `n > 1`.  

Given an integer `n`, return `F(n)`.  

**Example:**  

Input: `n = 2`  
Output: `1`  
Explanation: `F(2) = F(1) + F(0) = 1 + 0 = 1`.  

Input: `n = 3`  
Output: `2`  
Explanation: `F(3) = F(2) + F(1) = 1 + 1 = 2`.  

Input: `n = 4`  
Output: `3`  
Explanation: `F(4) = F(3) + F(2) = 2 + 1 = 3`.  

**Constraints:**  
- `0 <= n <= 30`  

**Hints:**  
1. Consider using recursion for a direct implementation.  
2. Iterative or memoization-based solutions can optimize performance.  

[📂 Solution](Solutions/0509.java)  

[⬆️ Go to top](#top)  

---

### ✅ Can Place Flowers  
**Difficulty:** 🟢 Easy  

**Problem Statement:**  
You have a long **flowerbed** in which some of the plots are planted, and some are not. However, **flowers cannot be planted in adjacent plots**.  

Given an integer array `flowerbed` containing **0's and 1's**:  
- `0` means **empty**.  
- `1` means **occupied**.  

And an integer `n`, return `true` if `n` new flowers can be planted in the flowerbed **without violating the no-adjacent-flowers rule**, otherwise return `false`.  

**Example 1:**  
**Input:** flowerbed = [1,0,0,0,1], n = 1  
**Output:** true  

**Example 2:**  
**Input:** flowerbed = [1,0,0,0,1], n = 2  
**Output:** false  

**Constraints:**  
- 1 <= flowerbed.length <= 2 × 10⁴  
- `flowerbed[i]` is `0` or `1`.  
- There are **no two adjacent flowers** in `flowerbed`.  
- 0 <= n <= flowerbed.length  

[📂 Solution](Solutions/0605.java)  

[⬆️ Go to top](#top)  

---

### ✅ Maximum Average Subarray I  
**Difficulty:** 🟢 Easy  

**Problem Statement:**  
You are given an integer array `nums` consisting of `n` elements, and an integer `k`.  

Find a **contiguous subarray** of length **k** that has the **maximum average value** and return this value.  
Any answer with a calculation error **less than 10⁻⁵** will be accepted.  

**Example 1:**  
**Input:** nums = [1,12,-5,-6,50,3], k = 4  
**Output:** 12.75000  
**Explanation:**  
Maximum average is **(12 - 5 - 6 + 50) / 4 = 51 / 4 = 12.75**  

**Example 2:**  
**Input:** nums = [5], k = 1  
**Output:** 5.00000  

**Constraints:**  
- `n == nums.length`  
- `1 <= k <= n <= 10⁵`  
- `-10⁴ <= nums[i] <= 10⁴`  

[📂 Solution](Solutions/0643.java)  

[⬆️ Go to top](#top)  

---

### ✅ Robot Return to Origin  
**Difficulty:** 🟢 Easy  

**Problem Statement:**  
There is a robot starting at position `(0, 0)`, the origin, on a 2D plane. Given a sequence of its moves, determine if the robot ends up at `(0, 0)` after completing all moves.  

You are given a string `moves` where `moves[i]` represents the `i`-th move. The valid moves are:  
- `'R'` (right)  
- `'L'` (left)  
- `'U'` (up)  
- `'D'` (down)  

Return `true` if the robot returns to the origin after finishing all moves, or `false` otherwise.  

**Note:**  
- The direction the robot is "facing" is irrelevant.  
- Each move has the same magnitude.  

**Example:**  

Input: `moves = "UD"`  
Output: `true`  
Explanation: The robot moves up once, then down once. Since all moves have equal magnitude, it returns to the origin `(0, 0)`.  

Input: `moves = "LL"`  
Output: `false`  
Explanation: The robot moves left twice, ending up two moves to the left of the origin. Since it is not at `(0, 0)`, we return `false`.  

**Constraints:**  
- `1 <= moves.length <= 2 * 10^4`  
- `moves` contains only the characters `'U'`, `'D'`, `'L'`, and `'R'`.  

**Hints:**  
1. Consider tracking the net displacement along the x-axis (`'L'` vs. `'R'`) and y-axis (`'U'` vs. `'D'`).  
2. If both net displacements are zero, the robot returns to the origin.  

[📂 Solution](Solutions/0657.java)  

[⬆️ Go to top](#top)  

---

### ✅ Baseball Game  
**Difficulty:** 🟢 Easy  

**Problem Statement:**  
You are keeping the scores for a baseball game with strange rules. At the beginning of the game, you start with an empty record.  

You are given a list of strings `operations`, where `operations[i]` is the `i-th` operation you must apply to the record. The operations are:  

1. **An integer `x`** → Record a new score of `x`.  
2. **'+'** → Record a new score that is the **sum** of the previous two scores.  
3. **'D'** → Record a new score that is **double** the previous score.  
4. **'C'** → Invalidate the previous score, **removing it** from the record.  

Return the **sum of all scores** on the record after applying all operations.  

**Example:**  

Input: `ops = ["5","2","C","D","+"]`  
Output: `30`  
Explanation:  
```
"5" → Add 5 to the record → [5]  
"2" → Add 2 to the record → [5, 2]  
"C" → Remove previous score → [5]  
"D" → Double the previous score (5 * 2 = 10) → [5, 10]  
"+" → Sum last two scores (5 + 10 = 15) → [5, 10, 15]  
Total sum: 5 + 10 + 15 = 30  
```

Input: `ops = ["5","-2","4","C","D","9","+","+"]`  
Output: `27`  
Explanation:  
```
"5" → [5]  
"-2" → [5, -2]  
"4" → [5, -2, 4]  
"C" → Remove previous score → [5, -2]  
"D" → Double previous score (-2 * 2 = -4) → [5, -2, -4]  
"9" → [5, -2, -4, 9]  
"+" → Sum last two scores (-4 + 9 = 5) → [5, -2, -4, 9, 5]  
"+" → Sum last two scores (9 + 5 = 14) → [5, -2, -4, 9, 5, 14]  
Total sum: 5 + (-2) + (-4) + 9 + 5 + 14 = 27  
```

Input: `ops = ["1","C"]`  
Output: `0`  
Explanation:  
```
"1" → [1]  
"C" → Remove previous score → []  
Total sum: 0  
```

**Constraints:**  
- `1 <= operations.length <= 1000`  
- `operations[i]` is `"C"`, `"D"`, `"+"`, or an integer in the range `[-30,000, 30,000]`.  
- For operation `"+"`, there will always be **at least two** previous scores on the record.  
- For operations `"C"` and `"D"`, there will always be **at least one** previous score on the record.  

**Hints:**  
1. Use a **stack** to keep track of valid scores.  
2. For `"+"`, access the last two elements of the stack.  
3. For `"D"`, access the last element of the stack.  
4. For `"C"`, remove the last element of the stack.  

[📂 Solution](Solutions/0682.java)  

[⬆️ Go to top](#top)  

---

### ✅ To Lower Case  
**Difficulty:** 🟢 Easy  

**Problem Statement:**  
Given a string `s`, return the string after replacing every **uppercase letter** with the **same lowercase letter**.  

**Example:**  

Input: `s = "Hello"`  
Output: `"hello"`  

Input: `s = "here"`  
Output: `"here"`  

Input: `s = "LOVELY"`  
Output: `"lovely"`  

**Constraints:**  
- `1 <= s.length <= 100`  
- `s` consists of **printable ASCII characters**.  

**Hints:**  
1. Most languages provide built-in functions for lowercase conversion, but try to implement it yourself.  
2. Think about the **ASCII values** of uppercase and lowercase letters.  
3. There is a **mathematical relationship** between uppercase (`A-Z`) and lowercase (`a-z`) letters.  

[📂 Solution](Solutions/0709.java)  

[⬆️ Go to top](#top)  

---

### ✅ Lemonade Change  
**Difficulty:** 🟢 Easy  

**Problem Statement:**  
At a lemonade stand, each lemonade costs **$5**. Customers queue up and order **one at a time**, paying with either a **$5, $10, or $20 bill**. You must **provide the correct change** for each customer so that the net transaction equals $5.  

You **start with no change** in hand.  

Given an integer array `bills`, where `bills[i]` is the bill the `i-th` customer pays, return `true` if you can provide **every customer** with the correct change, otherwise return `false`.  

**Example:**  

Input: `bills = [5,5,5,10,20]`  
Output: `true`  
Explanation:  
- Collect three **$5 bills** from the first three customers.  
- The fourth customer pays **$10**, give back **$5**.  
- The fifth customer pays **$20**, give back **$10** and **$5**.  
- Since every customer received correct change, return `true`.  

Input: `bills = [5,5,10,10,20]`  
Output: `false`  
Explanation:  
- Collect two **$5 bills** from the first two customers.  
- The next two customers pay **$10**, giving back **$5** each time.  
- The last customer pays **$20**, but we only have **two $10 bills**, so we **cannot** provide correct change.  
- Return `false`.  

**Constraints:**  
- `1 <= bills.length <= 10^5`  
- `bills[i]` is either `5`, `10`, or `20`.  

[📂 Solution](Solutions/0860.java)  

[⬆️ Go to top](#top)  

---

### ✅ Monotonic Array  
**Difficulty:** 🟢 Easy  

**Problem Statement:**  
An array is **monotonic** if it is either **monotone increasing** or **monotone decreasing**.  

- An array `nums` is **monotone increasing** if for all `i <= j`, `nums[i] <= nums[j]`.  
- An array `nums` is **monotone decreasing** if for all `i <= j`, `nums[i] >= nums[j]`.  

Given an integer array `nums`, return `true` if the given array is **monotonic**, otherwise return `false`.  

**Example:**  

Input: `nums = [1,2,2,3]`  
Output: `true`  

Input: `nums = [6,5,4,4]`  
Output: `true`  

Input: `nums = [1,3,2]`  
Output: `false`  

**Constraints:**  
- `1 <= nums.length <= 10^5`  
- `-10^5 <= nums[i] <= 10^5`  

[📂 Solution](Solutions/0896.java)  

[⬆️ Go to top](#top)  

---





<p align='center'>
   </br>  </br>  </br>  </br>
   <a href='#top'>↿ Go to top ↾
</p>
